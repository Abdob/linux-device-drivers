diff --git a/char_assignment/CDD2.c b/char_assignment/CDD2.c
index 1ace71c..a5ae422 100644
--- a/char_assignment/CDD2.c
+++ b/char_assignment/CDD2.c
@@ -1,12 +1,12 @@
 // Example# 3.6b: Simple Char Driver with Static or Dynamic Major# 
 //		  as requested at install-time.
-//		works only in 2.6 (.. a la Example# 3.2)
+//                works only in 2.6 (.. a la Example# 3.2)
 
-//      using dev_t, struct cdev (2.6)	  (example 3.1b)
-//      using myCDD structure		   (example 3.2b)
+//      using dev_t, struct cdev (2.6)          (example 3.1b)
+//      using myCDD structure                   (example 3.2b)
 //      using file->private_data structure      (example 3.3b)
-//      using container_of() macro	      (example 3.4b)
-//      using Static/Dynamic Major#	  	(example 3.5b)
+//      using container_of() macro              (example 3.4b)
+//      using Static/Dynamic Major#          	(example 3.5b)
 //      using Static/Dynamic Major# as a param  (example 3.6b)
 //      using O_TRUNC and O_APPEND				(here .. example 3.7b)
 
@@ -55,42 +55,41 @@ static unsigned int CDDparm = CDDMAJOR;
 dev_t   firstdevno;
 struct CDDdev_struct {
 	unsigned int    counter;
-	char	    *CDD_storage;
-	struct cdev     cdev;
-				int							append;
+	char            *CDD_storage;
+ 	struct cdev     cdev;
 };
 
 static struct CDDdev_struct myCDD;
 
 static int CDD_open (struct inode *inode, struct file *file)
 {
-	struct CDDdev_struct *thisCDD=
- 		container_of(inode->i_cdev, struct CDDdev_struct, cdev);
-	thisCDD->append=0;
+ 	struct CDDdev_struct *thisCDD=
+  	container_of(inode->i_cdev, struct CDDdev_struct, cdev);
 
-	if ( file->f_flags & O_TRUNC )  {
-		printk(KERN_ALERT "file '%s' opened O_TRUNC\n",
+	if ( file->f_flags & O_TRUNC )  
+	{
+ 		printk(KERN_ALERT "file '%s' opened O_TRUNC\n",
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
 			file->f_path.dentry->d_name.name);
 #else
 			file->f_dentry->d_name.name);
 #endif
-		thisCDD->CDD_storage[0]=0;
-		thisCDD->counter=0;
+
+    thisCDD->CDD_storage[0]=0;
+    thisCDD->counter=0;
 	}
 
-	if ( file->f_flags & O_APPEND )  {
-		printk(KERN_ALERT "file '%s' opened O_APPEND\n",
+	if ( file->f_flags & O_APPEND )  
+	{
+  	printk(KERN_ALERT "file '%s' opened O_APPEND\n",
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
 			file->f_path.dentry->d_name.name);
 #else
 			file->f_dentry->d_name.name);
 #endif
-		thisCDD->append=1;
 	}
 
-	file->private_data=thisCDD;
-
+  file->private_data=thisCDD;
 	return 0;
 }
 
@@ -107,75 +106,41 @@ static int CDD_release (struct inode *inode, struct file *file)
 static ssize_t CDD_read (struct file *file, char *buf, 
 size_t count, loff_t *ppos)
 {
-	int err;
+	int len, err;
  	struct CDDdev_struct *thisCDD=file->private_data;
 
-  if( *ppos >= thisCDD->counter) return 0;
-  else if( *ppos + count >= thisCDD->counter)
-    count = thisCDD->counter - *ppos;
+	if( thisCDD->counter <= 0 ) return 0;
 
-  if( count <= 0 ) return 0;    
-	printk(KERN_ALERT "CDD_read: count=%lu\n", count);
+	err = copy_to_user(buf,thisCDD->CDD_storage,thisCDD->counter);
 
-	// bzero(buf,64);  // a bogus 64byte initialization
-	memset(buf,0,64);  // a bogus 64byte initialization
-	err = copy_to_user(buf,&(thisCDD->CDD_storage[*ppos]),count);
 	if (err != 0) return -EFAULT;
-	
-	buf[count]=0;
-	*ppos += count;
-	return count;
+
+	len = thisCDD->counter;
+	thisCDD->counter = 0;
+	return len;
 }
 
 static ssize_t CDD_write (struct file *file, const char *buf, 
 size_t count, loff_t *ppos)
 {
-	int err, pos=0;
-	struct CDDdev_struct *thisCDD=file->private_data;
-
-	pos=(thisCDD->append)?thisCDD->counter:*ppos;
+	int err;
+       	struct CDDdev_struct *thisCDD=file->private_data;
 
-	err = copy_from_user(&(thisCDD->CDD_storage[pos]),buf,count);
+	err = copy_from_user(thisCDD->CDD_storage,buf,count);
 	if (err != 0) return -EFAULT;
 
 	thisCDD->counter += count;
-	*ppos+=count;
 	return count;
 }
-static loff_t CDD_llseek (struct file *file, loff_t newpos, int whence)
-{
-  int pos;
-	struct CDDdev_struct *thisCDD=file->private_data;
-
-	switch(whence) {
-		case SEEK_SET:	// CDDoffset can be 0 or +ve
-			pos=newpos;
-			break;
-		case SEEK_CUR:	// CDDoffset can be 0 or +ve
-			pos=(file->f_pos + newpos);
-			break;
-		case SEEK_END:	// CDDoffset can be 0 or +ve
-			pos=(thisCDD->counter + newpos);
-			break;
-		default:
-			return -EINVAL;
-	}
-	if ((pos < 0)||(pos>thisCDD->counter)) 
-		return -EINVAL;
-				
-	file->f_pos = pos;
-	return pos;
-}
 
 static struct file_operations CDD_fops =
 {
 	// for LINUX_VERSION_CODE 2.4.0 and later 
 	owner:	THIS_MODULE, 	// struct module *owner
-	open:		CDD_open, 		// open method 
-	read:   CDD_read,			// read method 
-	write:  CDD_write, 		// write method 
-	llseek: CDD_llseek,  	// covered in detail in Ch6. Just for fwd ref now.
-	release:CDD_release 	// release method
+	open:	CDD_open, 	// open method 
+	read:   CDD_read,	// read method 
+	write:  CDD_write, 	// write method 
+	release:  CDD_release 	// release method
 };
 
 static struct class *CDD_class;
@@ -206,38 +171,38 @@ static int CDD_init(void)
 	CDDmajor = CDDparm;
 
 	if (CDDmajor) {
-		//  Step 1a of 2:  create/populate device numbers
-		firstdevno = MKDEV(CDDmajor, CDDMINOR);
+        	//  Step 1a of 2:  create/populate device numbers
+        	firstdevno = MKDEV(CDDmajor, CDDMINOR);
 
-		//  Step 1b of 2:  request/reserve Major Number from Kernel
-		i = register_chrdev_region(firstdevno,1,CDD);
-		if (i < 0) { printk(KERN_ALERT "Error (%d) adding CDD", i); return i;}
+        	//  Step 1b of 2:  request/reserve Major Number from Kernel
+        	i = register_chrdev_region(firstdevno,1,CDD);
+        	if (i < 0) { printk(KERN_ALERT "Error (%d) adding CDD", i); return i;}
 	}
 	else {
-		//  Step 1c of 2:  Request a Major Number Dynamically.
-		i = alloc_chrdev_region(&firstdevno, CDDMINOR, CDDNUMDEVS, CDD);
-		if (i < 0) { printk(KERN_ALERT "Error (%d) adding CDD", i); return i;}
-		CDDmajor = MAJOR(firstdevno);
+        	//  Step 1c of 2:  Request a Major Number Dynamically.
+                i = alloc_chrdev_region(&firstdevno, CDDMINOR, CDDNUMDEVS, CDD);
+        	if (i < 0) { printk(KERN_ALERT "Error (%d) adding CDD", i); return i;}
+                CDDmajor = MAJOR(firstdevno);
 		printk(KERN_ALERT "kernel assigned major number: %d to CDD\n", CDDmajor);
 	}
 
-	CDD_class = class_create(THIS_MODULE, "CDD");
+  CDD_class = class_create(THIS_MODULE, "CDD");
   if (IS_ERR(CDD_class))
     return PTR_ERR(CDD_class);
 
   CDD_class->devnode = CDD_devnode;
   device_create(CDD_class, NULL, MKDEV(CDDmajor, 0), NULL, CDD);
 
-	//  Step 2a of 2:  initialize thisCDD->cdev struct
-	cdev_init(&thisCDD->cdev, &CDD_fops);
+  //  Step 2a of 2:  initialize thisCDD->cdev struct
+  cdev_init(&thisCDD->cdev, &CDD_fops);
 
-	//  Step 2b of 2:  register device with kernel
-	thisCDD->cdev.owner = THIS_MODULE;
-	thisCDD->cdev.ops = &CDD_fops;
-	i = cdev_add(&thisCDD->cdev, firstdevno, CDDNUMDEVS);
-	if (i) { printk(KERN_ALERT "Error (%d) adding CDD", i); return i; }
+  //  Step 2b of 2:  register device with kernel
+  thisCDD->cdev.owner = THIS_MODULE;
+  thisCDD->cdev.ops = &CDD_fops;
+  i = cdev_add(&thisCDD->cdev, firstdevno, CDDNUMDEVS);
+  if (i) { printk(KERN_ALERT "Error (%d) adding CDD", i); return i; }
 
-	return 0;
+  return 0;
 
 }
 
@@ -246,11 +211,11 @@ static void CDD_exit(void)
 	struct CDDdev_struct *thisCDD=&myCDD;
 
 	vfree(thisCDD->CDD_storage);
-	
+        
 	//  Step 1 of 2:  unregister device with kernel
  	cdev_del(&thisCDD->cdev);
 
-	device_destroy(CDD_class, MKDEV(CDDmajor, 0));
+  device_destroy(CDD_class, MKDEV(CDDmajor, 0));
   class_destroy(CDD_class);
 
  	//  Step 2b of 2:  Release request/reserve of Major Number from Kernel
